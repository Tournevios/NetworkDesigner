#include "NetworkDesignerParser.h"
#include <QtXml/QDomDocument>
#include <QtXml/QDomElement>
#include <QtXml/QDomNode>
#include <QTextStream>
#include <QtGui/QMessageBox>
#include <QFile>
#include <iostream>
#include <string>

/*
 * Useful when loading data.
 */
NetworkDesignerParser::NetworkDesignerParser()
{
	network = NULL;
	updateSchedulingPlan = NULL;
}

/*
 * Useful when performing a saving operation
 */
NetworkDesignerParser::NetworkDesignerParser(Network * network, UpdateSchedulingPlan * updateSchedulingPlan){
	this->network = network;
	this->updateSchedulingPlan = updateSchedulingPlan;
}

/*
 * This setter will be useful before saving data.
 * Setter for the network.
 */
void NetworkDesignerParser::setNetwork(Network * network){
	this->network = network;
}

/*
 * Setter for the UpdateSchedulingPlan.
 * Useful when saving data.
 */
void NetworkDesignerParser::setUpdateSchedulingPlan(UpdateSchedulingPlan * updateSchedulingPlan){
	this->updateSchedulingPlan = updateSchedulingPlan;
}


/*
 * Getter for the network.
 * Useful when loading data.
 */
Network * NetworkDesignerParser::getNetwork() const{
	return network;
}

/*
 * Getter for the UpdateShcedulingPlan
 * Useful when loading data.
 */
UpdateSchedulingPlan * NetworkDesignerParser::getUpdateSchedulingPlan() const{
	return updateSchedulingPlan;
}


/*
 * This methods creates a GNBox Premodel file based on the structure of the network
 */
/*
void NetworkDesignerParser::exportToGNBoxPremodel(QString fileName){

	QTextStream out;
	QFile file;
	QString justFileName = fileName.section("/",-1,-1);
	justFileName = justFileName.section(".",0,0);

	file.setFileName(fileName);
	if(!file.open(QIODevice::WriteOnly)) return;
	out.setDevice(&file);
*/
//	Exemple type d'un fichier premodel
//	Commentaire
//	:- module(premodel_fusion, [premodel/1]).

//	premodel(Premodel) :-
//		Premodel = [Species, LI, Nb_thr, Thr_ord],
//		Species = [x,y,z],
//		LI =
//		[
//		 c(x,[i(x,1),i(y,1),i(z,1)]),
//		 c(y,[i(x,1),i(y,1),i(z,1)]),
//		 c(z,[i(x,1),i(y,1),i(z,1)])
//		 ],
//
//		Nb_thr = [1,1,1],
//		Thr_ord = [].


//	out << "/*\n";
//	out << "\tPremodel File for GNBox Generated by NetworkDesigner\n";
//	out << "\tNumber of species: " << network->getNbNeurons() <<"\n";
//	out << "*/\n\n\n";
/*	out << ":-module("<< justFileName <<",[premodel/1]).\n\n";
	out << "premodel(Premodel) :-\n";
	out << "\tPremodel = [Species, LI, Nb_thr, Thr_ord],\n";
	out << "\tSpecies = [";
	for(int i=0; i < network->getNbNeurons() - 1;i++)
		out << "x_" << i << ",";
	out << "x_" << network->getNbNeurons() - 1 << "],\n";
	out << "\tLI = \n";
	out << "\t[\n";
	for(int i=0; i < network->getNbNeurons() - 1;i++){
			out << "\tc(x_" << i << ",[";
			for(int i=0; i < network->getNbNeurons() - 1;i++)
				out << "i(x_" << i <<",1),";
			out << "i(x_" << network->getNbNeurons() - 1 <<",1)]),\n";
	}
	out << "\tc(x_" << network->getNbNeurons() - 1 << ",[";
	for(int i=0; i < network->getNbNeurons() - 1;i++)
			out << "i(x_" << i <<",1),";
	out << "i(x_" << network->getNbNeurons() - 1 <<",1)])\n\t],\n\n";
	out << "\tNb_thr = [";
	for(int i=0;i < network->getNbNeurons()-1; i++) out << "1,";
	out << "1],\n";
	out << "\tThr_ord = [].\n";

	file.close();
}
*/
/*
 * This methods creates a GNBox Premodel file based on the structure of the network
 * Second Version: conserving graph structure
 */

/*
void NetworkDesignerParser::exportToGNBoxPremodel(QString fileName){

	QTextStream out;
	QFile file;
	QString justFileName = fileName.section("/",-1,-1);
	int k = 0;
	bool interact = false, putAComma = false;
	justFileName = justFileName.section(".",0,0);

	file.setFileName(fileName);
	if(!file.open(QIODevice::WriteOnly)) return;
	out.setDevice(&file);

*/
	//out << "/*\n";
/*	out << "\tPremodel File for GNBox Generated by NetworkDesigner\n";
	out << "\tNumber of species: " << network->getNbNeurons() <<"\n";
*/
//	out << "*/\n\n\n";
/*	out << ":-module(premodel_"<< justFileName <<",[premodel/1]).\n\n";
	out << "premodel(Premodel) :-\n";
	out << "\tPremodel = [Species, LI, Nb_thr, Thr_ord],\n";
	out << "\tSpecies = [";
	for(int i=0; i < network->getNbNeurons() - 1;i++)
		out << "x_" << i << ",";
	out << "x_" << network->getNbNeurons() - 1 << "],\n";
	out << "\tLI = \n";
	out << "\t[\n";
	for(int i=0; i < network->getNbNeurons();i++){
		putAComma = false;
		out << "\tc(x_" << i << ",[";
			for(int j=0; j < network->getNbNeurons();j++){
				interact = false;
				k=0;
				while((not interact) and (k < network->getNeuron(j)->getNb_neighbors())){
					if(network->getNeuron(j)->getNeighbor(k)->getIndex() == i){
						interact = true;
						break;
					}
					k++;
				}
				if(interact and not putAComma){
					out << "i(x_" << j <<",1)";
					putAComma = true;
				}
				else if (interact and putAComma)
					out << ", i(x_" << j <<",1)";
			}
			if(i == network->getNbNeurons()-1)
				out << "])\n\t],\n\n";
			else
				out << "]),\n";
	}

	out << "\tNb_thr = [";
	for(int i=0;i < network->getNbNeurons()-1; i++) out << "1,";
	out << "1],\n";
	out << "\tThr_ord = [].\n";

	file.close();
}
*/
void NetworkDesignerParser::exportToGNBoxPremodel(QString fileName){

	QTextStream out;
	QFile file;
	QString justFileName = fileName.section("/",-1,-1);
	int k = 0;
	bool interact = false, putAComma = false, putCommasInTheEndOfLines = false;
	justFileName = justFileName.section(".",0,0);

	file.setFileName(fileName);
	if(!file.open(QIODevice::WriteOnly)) return;
	out.setDevice(&file);

	/* Exemple type d'un fichier premodel
	Commentaire
	:- module(premodel_fusion, [premodel/1]).

	premodel(Premodel) :-
		Premodel = [Species, LI, Nb_thr, Thr_ord],
		Species = [x,y,z],
		LI =
		[
		 c(x,[i(x,1),i(y,1),i(z,1)]),
		 c(y,[i(x,1),i(y,1),i(z,1)]),
		 c(z,[i(x,1),i(y,1),i(z,1)])
		 ],

		Nb_thr = [1,1,1],
		Thr_ord = [].
		*/

	out << "/*\n";
	out << "\tPremodel File for GNBox Generated by NetworkDesigner\n";
	out << "\tNumber of species: " << network->getNbNeurons() <<"\n";
	out << "*/\n\n\n";
	out << ":-module(premodel_"<< justFileName <<",[premodel/1]).\n\n";
	out << "premodel(Premodel) :-\n";
	out << "\tPremodel = [Species, LI, Nb_thr, Thr_ord],\n";
	out << "\tSpecies = [";
	for(int i=0; i < network->getNbNeurons() - 1;i++)
		out << "x_" << i << ",";
	out << "x_" << network->getNbNeurons() - 1 << "],\n";
	out << "\tLI = \n";
	out << "\t[";
	for(int i=0; i < network->getNbNeurons();i++){
		/*
		 * Dans le cas ou c'est un jardin d'eden, je rajoute
		 * une interaction fictive d'autoactivation
		 * C'est fait pour avoir des fichiers model sans soucis
		 *
		 */
		if(network->getNeuron(i)->getNb_neighbors() == 0) {
			if(putCommasInTheEndOfLines)
				out << ",\n\tc(x_" << i << ",[i(x_" << i <<",1)])";
			else{
					putCommasInTheEndOfLines = true;
					out << "\n\tc(x_" << i << ",[i(x_" << i <<",1)])";
			}
			continue;
		}
		putAComma = false;
		if(putCommasInTheEndOfLines)
			out << ",\n\tc(x_" << i << ",[";
		else{
			out << "\n\tc(x_" << i << ",[";
			putCommasInTheEndOfLines = true;
		}
			for(int j=0; j < network->getNeuron(i)->getNb_neighbors() ;j++){
				/*interact = false;
				k=0;
				while((not interact) and (k < network->getNeuron(j)->getNb_neighbors())){
					if(network->getNeuron(j)->getNeighbor(k)->getIndex() == i){
						interact = true;
						break;
					}
					k++;
				}*/
				if(not putAComma){
					out << "i(x_" << network->getNeuron(i)->getSynapse(j)->getFinalNeuron()->getIndex() <<",1)";
					putAComma = true;
				}
				else
					out << ", i(x_" << network->getNeuron(i)->getSynapse(j)->getFinalNeuron()->getIndex() <<",1)";
			}
				out << "])";
	}

	out << "\n\t],\n\n";

	/*out << "\tc(x_" << network->getNbNeurons() - 1 << ",[";
	for(int i=0; i < network->getNbNeurons() - 1;i++)
			out << "i(x_" << i <<",1),";
	out << "i(x_" << network->getNbNeurons() - 1 <<",1)])\n\t],\n\n";*/
	out << "\tNb_thr = [";
	for(int i=0;i < network->getNbNeurons()-1; i++) out << "1,";
	out << "1],\n";
	out << "\tThr_ord = [].\n";

	file.close();
}


/*
 * This methods use Qt DOM to parse the network, the UpdateSchedulingPlan and the simulation.
 * The first child of the root node is the network: the network contains neurons
 * Each neuron of the network is saved with its attributes.
 * The second child of the root node is the UpdateSchedulingPlan which is composed by UpdateBlocks
 * Each UpdateBlock is saved with its attributes.
 */
void NetworkDesignerParser::save(QString fileName){

	QDomDocument doc;

	QDomElement pRoot;
	QDomElement pNetwork;
	QDomElement pNeuron;
	QDomElement pState;
	QDomElement pSynapse;

	QDomElement pUpdateSchedulingPlan;
	QDomElement pUpdateBlock;
	QDomElement pNeuronIndex;

	QTextStream out;
	QFile file;
	Neuron * neuron;

	pRoot = doc.createElement("Configuration");

	doc.appendChild(pRoot);

	pNetwork = doc.createElement("Network");

	if(network != NULL){
		pNetwork.setAttribute("Nb_Neurons", network->getNbNeurons());
		pNetwork.setAttribute("Temperature", network->getTemperature());
		pNetwork.setAttribute("UniformalTemperature", network->getUniformalTemperature());
	}
	else{
		pNetwork.setAttribute("Nb_Neurons", 0);
		pNetwork.setAttribute("Temperature", 0.001);
	}

	pRoot.appendChild(pNetwork);


	pUpdateSchedulingPlan = doc.createElement("UpdateSchedulingPlan");

	if(updateSchedulingPlan!=NULL)
		pUpdateSchedulingPlan.setAttribute("Nb_UpdateBlocks", updateSchedulingPlan->getNb_blocks());
	else
		pUpdateSchedulingPlan.setAttribute("Nb_UpdateBlocks", 0);
	pRoot.appendChild(pUpdateSchedulingPlan);

	file.setFileName(fileName);
	if(!file.open(QIODevice::WriteOnly)) return;
	out.setDevice(&file);

	if(network!=NULL){
		for(int i=0; i< network->getNbNeurons(); i++){
			neuron = network->getNeuron(i);
			pNeuron = doc.createElement("Neuron");
			pNeuron.setAttribute("Index", neuron->getIndex());
			pNeuron.setAttribute("NodeID", neuron->getNodeID());
			pNeuron.setAttribute("State", neuron->getState());
			pNeuron.setAttribute("NbStates", neuron->getNbStates());
			pNeuron.setAttribute("Temperature", neuron->getTemperature());
			pNeuron.setAttribute("Nb_Neighbors", neuron->getNb_neighbors());
			pNeuron.setAttribute("x", neuron->getX());
			pNeuron.setAttribute("y", neuron->getY());
			for(int s=0; s < neuron->getNbStates() - 1; s++){
				pState = doc.createElement("State");
				pState.setAttribute("Index", s+1);
				pState.setAttribute("Threshold", neuron->getThreshold(s+1));
				pNeuron.appendChild(pState);
			}

			if(neuron->getNb_neighbors() > 0){
				for(int j=0; j < neuron->getNb_neighbors(); j++){
					pSynapse = doc.createElement("Synapse");
					pSynapse.setAttribute("NeighborIndex", neuron->getNeighbor(j)->getIndex());
					pSynapse.setAttribute("Weight", neuron->getSynapseWeight(j));
					pSynapse.setAttribute("Delay", neuron->getSynapseDelay(j));
					pSynapse.setAttribute("CX", neuron->getSynapse(j)->getCX());
					pSynapse.setAttribute("CY", neuron->getSynapse(j)->getCY());
					pNeuron.appendChild(pSynapse);
				}
			}
			pNetwork.appendChild(pNeuron);
		}
	}
	if(updateSchedulingPlan!=NULL){
		for(int i=0; i < updateSchedulingPlan->getNb_blocks(); i++){
			pUpdateBlock = doc.createElement("Block");
			pUpdateBlock.setAttribute("Size", updateSchedulingPlan->getUpdateBlock(i)->getSize());
			pUpdateBlock.setAttribute("Calculus", updateSchedulingPlan->getUpdateBlock(i)->getUpdateMethods());
			for(int j = 0; j < updateSchedulingPlan->getUpdateBlock(i)->getSize(); j++){
				pNeuronIndex = doc.createElement("NeuronIndex");
				pNeuronIndex.setAttribute("Index", updateSchedulingPlan->getUpdateBlock(i)->getNeuronIndex(j));
				pUpdateBlock.appendChild(pNeuronIndex);
			}
			pUpdateSchedulingPlan.appendChild(pUpdateBlock);
		}
	}
	 //Insert in the begining of the document <?xml version="1.0" ?>
	QDomNode noeud = doc.createProcessingInstruction("xml","version=\"1.0\"");
	doc.insertBefore(noeud,doc.firstChild());
	// save into the stream with 2 blanks as decay beetween levels
	doc.save(out,2);
	file.close();
}

void NetworkDesignerParser::load(QString fileName){

	QDomDocument doc;

	QDomElement root;

	QDomNode node;
	QDomNode child;
	QDomNode grandChild;
	QMessageBox a(0);

	QFile file(fileName);

	int Nb_Neurons;
	int Nb_Neighbors;


	int neighborIndex;
	double weight;
	int delay;
	double cx, cy;

	int Nb_UpdateBlocks;
	int block_size;
	int calculus;

	UpdateBlock* updateBlock;

	bool * okki = (bool *) malloc(sizeof(bool));


	if (!file.open(QIODevice::ReadOnly)) return;
	if (!doc.setContent(&file)) {        // Set the XML document from the file data
     file.close();
	}
	file.close();

	root = doc.documentElement();		// the first Element "Configuration"
	node = root.firstChild();			// The first node "Network"


	Nb_Neurons = node.toElement().attribute("Nb_Neurons").toInt(okki);
	network = new Network(node.toElement().attribute("Temperature").toDouble(okki));		// Read the Temperature parameter
	network->setUniformalTemperature((bool)(node.toElement().attribute("UniformalTemperature").toInt(okki))); // Read if the temperature is uniform or note
	if(Nb_Neurons>0){
		for(int i=0; i < Nb_Neurons;i++)	network->addNeuron(new Neuron());
		child = node.firstChild();											// Read neurons
		for(int i=0; i < Nb_Neurons;i++){
			network->getNeuron(i)->setNbStates(child.toElement().attribute("NbStates").toInt(okki));
			network->getNeuron(i)->setState(child.toElement().attribute("State").toInt(okki));
			network->getNeuron(i)->setTemperature(child.toElement().attribute("Temperature").toDouble(okki));
			network->getNeuron(i)->setX(child.toElement().attribute("x").toDouble(okki));
			network->getNeuron(i)->setY(child.toElement().attribute("y").toDouble(okki));
			network->getNeuron(i)->setNodeID((char*)(child.toElement().attribute("NodeID", "noname").toStdString().c_str()));
			Nb_Neighbors = child.toElement().attribute("Nb_Neighbors").toInt(okki);

			if(network->getNeuron(i)->getNbStates() >= 2){
				grandChild = child.firstChild();
				for(int  j=1; j < network->getNeuron(i)->getNbStates(); j++){
					network->getNeuron(i)->setThreshold(j, grandChild.toElement().attribute("Threshold").toDouble(okki));
					if(j+1 < network->getNeuron(i)->getNbStates()) grandChild = grandChild.nextSibling();
				}
			}

			if(Nb_Neighbors>0){
				if(network->getNeuron(i)->getNbStates() < 2){
					grandChild = child.firstChild();
				}
				else{
					grandChild = grandChild.nextSibling();
				}
				for(int j=0; j < Nb_Neighbors; j++){
					neighborIndex = grandChild.toElement().attribute("NeighborIndex").toInt(okki);
					weight = grandChild.toElement().attribute("Weight").toDouble(okki);
					delay = grandChild.toElement().attribute("Delay").toInt(okki);
					cx = grandChild.toElement().attribute("CX").toDouble(okki);
					cy = grandChild.toElement().attribute("CY").toDouble(okki);
					network->getNeuron(i)->addSynapse(network->getNeuron(neighborIndex), weight, delay);
					network->getNeuron(i)->getSynapse(j)->setCX(cx);
					network->getNeuron(i)->getSynapse(j)->setCY(cy);
					if (j+1 < Nb_Neighbors) grandChild = grandChild.nextSibling();
				}
			}
			if (i+1 < Nb_Neurons) child = child.nextSibling();
		}
	}
	network->deselectAll();

	node = node.nextSiblingElement();

	Nb_UpdateBlocks = node.toElement().attribute("Nb_UpdateBlocks").toInt(okki);

	updateSchedulingPlan = new UpdateSchedulingPlan();
	if(Nb_UpdateBlocks>0){
		child = node.firstChild();

		for(int i=0; i < Nb_UpdateBlocks; i++) {
			block_size = 0;
			block_size = child.toElement().attribute("Size").toInt(okki);
			calculus = child.toElement().attribute("Calculus").toInt(okki);
			updateBlock = new UpdateBlock();
			updateBlock->setUpdateMethods(calculus);
			if(block_size>0){
				grandChild = child.firstChild();
				for(int j=0; j< block_size; j++){
					updateBlock->addNeuronIndex(grandChild.toElement().attribute("Index").toInt(okki));
					if(j+1 < block_size) grandChild = grandChild.nextSibling();
				}
			}
			updateSchedulingPlan->addUpdateBlock(updateBlock);
			if(i+1 < Nb_UpdateBlocks) child = child.nextSibling();
		}
	}
	//a.setText(node.toElement().tagName());
	//a.exec();
	free (okki);
}

NetworkDesignerParser::~NetworkDesignerParser()
{
}
